

  //STRUCT FOR HOLDING ALL THE RELEVANT INFO

#include <gsl/gsl_rng.h>
#include <gsl/gsl_randist.h>


//move gsl vector into spec array
void UnPack(gsl_vector *x,mass *spec)
{
int i=0; //start incrementor for paramter number
if((*spec).fitpar.distparam>0)//if we're minimising the distribution, transfer params
  for(i=0;i<(*spec).fitpar.distparam;i++)
    (*spec).par[i]=gsl_vector_get (x, i);
if((*spec).fitpar.adduction_flg==1) //if we're minimising adduction, take the param
  {spec->adduction=gsl_vector_get (x, i);i++;}
if((*spec).fitpar.Zfudge_flg==1)    //if we're minimising Zfudge, take the param
  {spec->Zfudge=gsl_vector_get (x, i);i++;}
if((*spec).fitpar.MRes_flg==1)    //if we're minimising MRes, take the param
  {spec->MRes=gsl_vector_get (x, i);i++;}
if((*spec).fitpar.ResFudge_flg==1)    //if we're minimising ResFudge, take the param
  {spec->ResFudge=gsl_vector_get (x, i);i++;}
if((*spec).fitpar.tw_flg==1)    //if we're minimising residual 12mer, take the param
  {spec->tw=gsl_vector_get (x, i);i++;}
if((*spec).fitpar.Zwidth_flg==1)    //if we're minimising residual 12mer, take the param
  {spec->Zwidth=gsl_vector_get (x, i);i++;}
}

/* CALCULATE CHI^2 MATRIX */
int expb_f (const gsl_vector * x, void *data,gsl_vector * f)
{
  mass *spec=(mass* )data; //recast void pointer
UnPack(x,spec);
(*spec).run_calc(0);
//set chi vector
    for (size_t i = 0; i < (*spec).lines; i++)   //record and store chi values
      //chi(i) = (Ydata(i)-Ysim(i))/sigma
      gsl_vector_set (f, i,  ((*spec).data[i+(*spec).lines*1]-(*spec).data[i+(*spec).lines*2])/10 );
return GSL_SUCCESS;
}
  
  
  
  /* CALCULATE JACOBIAN MATRIX */
  int expb_df (const gsl_vector * x, void *data, gsl_matrix * J)
  {
    //cout << "CALCULATING DERIVATIES" << endl;

    mass *spec=(mass *)data;
    double STEP=1E-6;   //define step size for gradient differences
    
    double par[(*spec).limHSP*(*spec).limSub];
    {
      int i=0;  //start incrementor for paramter number
      
      if( (*spec).chap==7){//unique to the single species fitting...
	par[0]=(*spec).x_init[0]; //get the principle oligomer...
	par[1]=(*spec).x_init[1]; //get the number of extra species...
	for(int j=0;j<par[1];j++)
	  {
	    par[2*j+2]=(*spec).x_init[2*j+2]; //add the size of the next species...
	    //in par array, odd numbers that are not 1 are optimised
	    par[2*j+3]=gsl_vector_get (x, j); //get the concentration to optimise.
	    i++;
	  }
	//if( (*spec).params.distparam!=i){
	//cout << "PROBLEM WTIH PARAM COUNTING!" << endl;
	//exit(100);}
      }
      else
	if((*spec).fitpar.distparam>0)//if we're minimising the distribution, transfer params
	  for(i=0;i<(*spec).fitpar.distparam;i++)
	    {par[i]=gsl_vector_get (x, i);
	    }
	else //otherwise just take the default params
	  for(int j=0;j<10;j++)
	    par[j]=(*spec).x_init[j];
      
      if((*spec).fitpar.adduction_flg==1) //if we're minimising adduction, take the param
	{spec->adduction=gsl_vector_get (x, i);i++;}
      if((*spec).fitpar.Zfudge_flg==1)    //if we're minimising Zfudge, take the param
	{spec->Zfudge=gsl_vector_get (x, i);i++;}
      if((*spec).fitpar.MRes_flg==1)    //if we're minimising MRes, take the param
	{spec->MRes=gsl_vector_get (x, i);i++;}
      if((*spec).fitpar.ResFudge_flg==1)    //if we're minimising ResFudge, take the param
	{spec->ResFudge=gsl_vector_get (x, i);i++;}
      if((*spec).fitpar.tw_flg==1)    //if we're minimising residual 12mer, take the param
	{spec->tw=gsl_vector_get (x, i);i++;}
      if((*spec).fitpar.Zwidth_flg==1)    //if we're minimising residual 12mer, take the param
	{spec->Zwidth=gsl_vector_get (x, i);i++;}
    }
    
    (*spec).run_calc(0);
    double datum0[(*spec).lines*3];for (int i=0;i<(*spec).lines*3;i++) datum0[i]=(*spec).data[i];  //store the STEP=0 output for safe keeping...
    
    //if we're optimising the distribution:
    {
      int i=0;
      if((*spec).fitpar.distparam>0)
	for (i=0;i<(*spec).fitpar.distparam;i++)//loop over each distribution parameter (pp)
	  {
	    if((*spec).chap!=7){
	      for(int k=0;k<(*spec).fitpar.distparam;k++)//reset distribution parameters
		{
		  par[k]=gsl_vector_get (x, k);
		}
	      par[i]=par[i]+STEP;
	    }
	    else
	      {//only increment the concentration value
		par[0]=(*spec).x_init[0]; //get the principle oligomer...
		par[1]=(*spec).x_init[1]; //get the number of extra species...
		for(int j=0;j<par[1];j++){
		  par[2*j+2]=(*spec).x_init[2*j+2]; //add the size of the next species...
		  par[2*j+3]=gsl_vector_get (x, j); //get the concentration to optimise.
		}
		par[2*i+3]=par[2*i+3]+STEP*100; //increment distribution parameter
	      }
	    
	    
	    (*spec).run_calc(0);
	    
	    for (int j = 0;j < (*spec).lines; j++)//gradient will be Y(p)-Y(p+dp)
	      gsl_matrix_set (J, j, i, -1.0*( (*spec).data[j+(*spec).lines*2]-datum0[j+(*spec).lines*2] )/(STEP*10));
	    
	  }
      
      
      if((*spec).chap==8 || (*spec).chap==9 || (*spec).chap==3)  //set gradient of two parameters to zero for gridsearch
	{
	  for (int j = 0;j < (*spec).lines; j++)
	    gsl_matrix_set (J, j, 0, 0.0 );
	  for (int j = 0;j < (*spec).lines; j++)
	    gsl_matrix_set (J, j, 1, 0.0 );
	}
      
      
      //now check the gradients for each of the additional model parameters required by the minimisation
      if((*spec).fitpar.adduction_flg==1)
	{
	  for(int k=0;k<(*spec).fitpar.distparam;k++)
	    par[k]=gsl_vector_get (x, k);//reset distribution parameters
	  spec->adduction=(*spec).adduction+STEP;
	  (*spec).run_calc(0);
	  
	  for (int j = 0;j < (*spec).lines; j++)
	    //gradient will be Y(p)-Y(p+dp)
	    gsl_matrix_set (J, j, i, -1.0*( (*spec).data[j+(*spec).lines*2]-datum0[j+(*spec).lines*2] )/(STEP*10));
	  i++;
	  spec->adduction=(*spec).adduction-STEP;
	}
      
      if((*spec).fitpar.Zfudge_flg==1)
	{
	  for(int k=0;k<(*spec).fitpar.distparam;k++)
	    par[k]=gsl_vector_get (x, k);//reset distribution parameters
	  spec->Zfudge=(*spec).Zfudge+STEP;
	  (*spec).run_calc(0);
	  for (int j = 0;j < (*spec).lines; j++)
	    //gradient will be Y(p)-Y(p+dp)
	    gsl_matrix_set (J, j, i, -1.0*( (*spec).data[j+(*spec).lines*2]-datum0[j+(*spec).lines*2] )/(STEP*10));
	  i++;
	  spec->Zfudge=(*spec).Zfudge-STEP;
	}
      if((*spec).fitpar.MRes_flg==1)
	{
	  for(int k=0;k<(*spec).fitpar.distparam;k++)
	    par[k]=gsl_vector_get (x, k);//reset distribution parameters
	  spec->MRes=(*spec).MRes+STEP;
	  (*spec).run_calc(0);
	  for (int j = 0;j < (*spec).lines; j++)
	    //gradient will be Y(p)-Y(p+dp)
	    gsl_matrix_set (J, j, i, -1.0*( (*spec).data[j+(*spec).lines*2]-datum0[j+(*spec).lines*2] )/(STEP*10));
	  i++;
	  spec->MRes=(*spec).MRes-STEP;
	}
      if((*spec).fitpar.ResFudge_flg==1)
	{
	  for(int k=0;k<(*spec).fitpar.distparam;k++)
	    par[k]=gsl_vector_get (x, k);//reset distribution parameters
	  spec->ResFudge=(*spec).ResFudge+STEP;
	  (*spec).run_calc(0);
	  for (int j = 0;j < (*spec).lines; j++)
	    //gradient will be Y(p)-Y(p+dp)
	    gsl_matrix_set (J, j, i, -1.0*( (*spec).data[j+(*spec).lines*2]-datum0[j+(*spec).lines*2] )/(STEP*10));
	  i++;
	  spec->ResFudge=(*spec).ResFudge-STEP;
	}
      if((*spec).fitpar.tw_flg==1)
	{
	  for(int k=0;k<(*spec).fitpar.distparam;k++)
	    par[k]=gsl_vector_get (x, k);//reset distribution parameters
	  spec->tw=(*spec).tw+STEP;
	  (*spec).run_calc(0);
	  for (int j = 0;j < (*spec).lines; j++)
	    //gradient will be Y(p)-Y(p+dp)
	    gsl_matrix_set (J, j, i, -1.0*( (*spec).data[j+(*spec).lines*2]-datum0[j+(*spec).lines*2] )/(STEP*10));
	  i++;
	  spec->tw=(*spec).tw-STEP;
	}
      if((*spec).fitpar.Zwidth_flg==1)
	{
	  for(int k=0;k<(*spec).fitpar.distparam;k++)
	    par[k]=gsl_vector_get (x, k);//reset distribution parameters
	  spec->Zwidth=(*spec).Zwidth+STEP;
	  (*spec).run_calc(0);
	  for (int j = 0;j < (*spec).lines; j++)
	    //gradient will be Y(p)-Y(p+dp)
	    gsl_matrix_set (J, j, i, -1.0*( (*spec).data[j+(*spec).lines*2]-datum0[j+(*spec).lines*2] )/(STEP*10));
	  i++;
	  spec->Zwidth=(*spec).Zwidth-STEP;
	}
    }
    
    return GSL_SUCCESS;
  }
  
  
  //CALLS BOTH FUNCTION AND DERIVATIVE CALCULATOR
  int
    expb_fdf (const gsl_vector * x, void *data,
	      gsl_vector * f, gsl_matrix * J)
  {
    expb_f (x, data, f);
    expb_df (x,data, J);
    
    return GSL_SUCCESS;
  }
  
  
  //PRINTS CURRENT STATE OF ITERATOR
  void print_state (size_t iter, gsl_multifit_fdfsolver * s,int p)
  {
    printf ("iter: %3zu x = ",iter);
    if(p<10)
      for(int i=0;i<p;i++)
	printf("% 15.8f ",gsl_vector_get(s->x,i));
    printf(" |f(x)| = %g\n", gsl_blas_dnrm2 (s->f));
    
  }
  
  
//MAIN FUNCTION. SETS UP AND CALLS MINIMSER
void fitty(int flg,mass &spec)
  {

    spec.GetDistParams(); //set number of distribution parameters

    //work out number of fitting parameters
    int pp=spec.fitpar.distparam;
    size_t p = (pp+spec.fitpar.adduction_flg+spec.fitpar.Zfudge_flg+spec.fitpar.MRes_flg+spec.fitpar.ResFudge_flg+spec.fitpar.tw_flg+spec.fitpar.Zwidth_flg); //add on spectral params
    if(pp>0 && spec.chap>=10 && spec.fitpar.tw_flg==1) //for completely free distribution parameters
      p=p-1;

    
    //initialise minimiser
    gsl_matrix *covar = gsl_matrix_alloc (p, p);
    gsl_multifit_function_fdf f;
    double x_init2[p];

    spec.InitPars(x_init2,pp); //Initialise initial parameters

    const gsl_multifit_fdfsolver_type *T;
    gsl_multifit_fdfsolver *s;
    int status;
    unsigned int i, iter = 0;
    const size_t n = spec.lines; //number of datapoints

    gsl_vector_view x = gsl_vector_view_array (x_init2, p);
    
    f.f = &expb_f;
    f.df = &expb_df;
    f.fdf = &expb_fdf;
    f.n = n;
    f.p = p;
    f.params = &spec;
    if(flg==1)
      cout << "Fitting with "<< p << " total parameters " << endl;
    
    T = gsl_multifit_fdfsolver_lmsder;
    s = gsl_multifit_fdfsolver_alloc (T, n, p);
    gsl_multifit_fdfsolver_set (s, &f, &x.vector);
    if(flg==1)
      print_state (iter, s,p);
    do
      {
	iter++;
	status = gsl_multifit_fdfsolver_iterate (s);
	//printf ("status = %s\n", gsl_strerror (status));
	if(flg==1)
	  print_state (iter, s,p);
	if (status)
	  break;
	status = gsl_multifit_test_delta (s->dx, s->x,
					  1e-8, 1e-8);
      }
    while (status == GSL_CONTINUE && iter < 50);
    
    //gsl_multifit_covar (s->J, 0.0, covar);
    
#define FIT(i) gsl_vector_get(s->x, i)
#define ERR(i) sqrt(gsl_matrix_get(covar,i,i))
    
    double chi = gsl_blas_dnrm2(s->f);
    double dof = n - p;
    double c = GSL_MAX_DBL(1, chi / sqrt(dof));
    
    if(flg==1)
      printf("chisq/dof = %g\n",  pow(chi, 2.0) / dof);
    
    
    if(spec.chap<10 && spec.chap!=6 && spec.chap!=5)
      {
	if(flg==1){
	  printf("\nCovariance matrix\n");
	  for (int i=0;i<pp;i++)
	    {
	      for(int j=0;j<pp;j++)
		printf("%f\t",c*gsl_matrix_get(covar,i,j));
	      printf("\n");
	    }}
      }

    //UnPack(); //unpack fitting parameters

    double par[spec.limHSP*spec.limSub];
    
    {//a loop to store ii.
      int ii=0;
      
      if(spec.chap<10 && pp>0 && spec.chap!=5 && spec.chap!=6 && spec.chap!=7 && spec.chap!=2)
	{
	  if(flg==1)printf ("Hx0      = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	  if(flg==1)printf ("Hsig     = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	  if(flg==1)printf ("Sx0      = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	  if(flg==1)printf ("Ssig     = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	  
	  if(spec.chap==1 || spec.chap==9){
	    if(flg==1)printf ("alpha     = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;}
	  if(spec.chap==3){
	    if(flg==1)printf ("alpha     = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	    if(flg==1)printf ("alpha2    = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;}
	  if(spec.chap==4){
	    if(flg==1)printf ("alpha     = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	    if(flg==1)printf ("Hx0_0     = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	    if(flg==1)printf ("Hsig_0    = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	    if(flg==1)printf ("alpha_0   = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	    if(flg==1)printf ("rel       = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;}
	  
	  for (int j=0;j<pp;j++)
	    par[j]=spec.x_init[j];
	  
	}
      
      
      if(spec.chap==7)//Modified Poisson for single distribution
	{
	  //printf ("Rat      = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	  //	printf ("Mult     = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	  par[0]=spec.x_init[0];
	  par[1]=spec.x_init[1];
	  for (int j=0;j<pp;j++){
	    par[2*j+2]=spec.x_init[2*j+2];
	    par[2*j+3]=FIT(ii);ii++;
	  }
	}
      
      
      if(spec.chap==2)//Poisson for single distribution
	{
	  if(flg==1)printf ("Rat      = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	  if(flg==1)printf ("Mult     = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	  for (int j=0;j<pp;j++)
	    par[j]=spec.x_init[j];
	  
	}
      
      if(spec.chap==5)
	{
	  for(int j=0;j<spec.limSub;j++){
	    if(flg==1)printf ("%i Hx0_0     = %.5f +/- %.5f\n", j,FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	    if(flg==1)printf ("%i Hsig_0    = %.5f +/- %.5f\n", j,FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	    if(flg==1)printf ("%i alpha_0   = %.5f +/- %.5f\n", j,FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;}
	  for (int j=0;j<pp;j++)
	    par[j]=spec.x_init[j];
	}
      
      if(spec.chap==6)
	{
	  for(int j=0;j<spec.limSub;j++){
	    if(flg==1)printf ("%i Hx0_0     = %.5f +/- %.5f\n", j,FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	    if(flg==1)printf ("%i Hsig_0    = %.5f +/- %.5f\n", j,FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	    if(flg==1)printf ("%i alpha_0   = %.5f +/- %.5f\n", j,FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;
	    if(flg==1)printf ("%i rel       = %.5f +/- %.5f\n", j,FIT(ii), c*ERR(ii));spec.x_init[ii]=FIT(ii);ii++;}
	  for (int j=0;j<pp;j++)
	    par[j]=spec.x_init[j];
	}
      
      
      
      
      
      
      //    if(spec.chap<10 && pp==0)//do this if not fitting distribution at all
      //	for (int j=0;j<pp;j++)
      //	  par[j]=spec.x_init[j];
      
      
      if(spec.chap>=10 && pp>0)//do this if doing the 'all param' dist fit
	for (ii=0;ii<pp;ii++)
	  par[ii]=FIT(ii);
      
      
      
      //add on the 'extra' parameters
      if(spec.fitpar.adduction_flg==1){ if(flg==1)printf ("Adduction= %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));   spec.adduction=FIT(ii);ii++;}
      if(spec.fitpar.Zfudge_flg==1){    if(flg==1)printf ("Zfudge   = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));   spec.Zfudge=FIT(ii);   ii++;}
      if(spec.fitpar.MRes_flg==1){  	  if(flg==1)printf ("Mres     = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));   spec.MRes=FIT(ii);     ii++;}
      if(spec.fitpar.ResFudge_flg==1){  if(flg==1)printf ("ResFudge = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));   spec.ResFudge=FIT(ii); ii++;}
      if(spec.fitpar.tw_flg==1){	  if(flg==1)printf ("resid 12 = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));   spec.tw=FIT(ii);       ii++;}
      if(spec.fitpar.Zwidth_flg==1){	  if(flg==1)printf ("Zwidth = %.5f +/- %.5f\n", FIT(ii), c*ERR(ii));   spec.Zwidth=FIT(ii);       ii++;}
      
    }//end of loop for ii
    
    
    // printf("spec.chap = %i\t%f\t%f\n",spec.chap,par[0],par[4]);
    
    //double chi2=0;
    if(pp==0)
      for (int i =0; i<10; i++)
	par[i]=spec.x_init[i];

    spec.run_calc(flg);
    
    if(flg==1){
      printf ("internal chi2/dof %f\n",spec.chi2);
      printf ("status = %s\n", gsl_strerror (status));}
    
    
    gsl_multifit_fdfsolver_free (s);
    gsl_matrix_free (covar);

  }
  
  
  void gridsearch1D(int i,int j,int trial,int lines,double *data,double *x_init,struct mass& mass_init,struct control& params,string *raw,string *ident,double Max0,double Min0,double Max1,double Min1,char *GridType)
  {
    
    int maxsearch=(Max0-Min0)/2.0+1; //stepsize  for centroid
    
    /*    
    //initiate a grid search output file and mode
    FILE *fp;
    string labby="out/chi2init.out";
    labby.append(ident[i].c_str(),4);
    
    int jj=0;
    if(j==0){//for Gaussian
      jj=0;
      char *lab="_0";labby.append(lab,2);}
    if(j==1){//for Skewed Gaussian
      jj=1;
      char *lab="_1";labby.append(lab,2);}
    fp=fopen(labby.c_str(),"w");
    fclose(fp);
    
    if(params.spec.chap==0)
      params.spec.chap=8;
    if(params.spec.chap==2)
      params.spec.chap=3;
    //run the gridsearch to find optimum centre of substrate and client distributions
    double testym[maxsearch*maxsearch*3];
    int cnt=0;
    for (int k1=0;k1<maxsearch;k1++)
      {
	cout << "    Gridsearch progress: " << k1+1 << " of " << maxsearch << endl;
	for (int k2=0;k2<maxsearch;k2++)
	  {
	    testym[cnt+maxsearch*maxsearch*0]=Min0+(k1)/(maxsearch*1.0-1.0)*(Max0-Min0);  //grid search from 10 to 50 on 'rat'
	    if(GridType=="log")
	      testym[cnt+maxsearch*maxsearch*1]=Min1*pow(10,k2/(maxsearch*1.0-1.0)*log10(Max1/Min1));
	    else
	      testym[cnt+maxsearch*maxsearch*1]=Min1+(k2)/(maxsearch*1.0-1.0)*(Max1-Min1);  //grid search from 10 to 50 on 'rat'
	    
	  
	    //x_init[0] = 25.0;    //Hx0    substrate centre
	    //x_init[1] = 2.0;     //Hsig   substrate width
	    //x_init[2] = 2.0;     //Sxo    client centre
	    //x_init[3] = 1.0;     //Ssig   client width
	    //x_init[4] = 0.01;    //alpha  skew factor
	    
	    x_init[0]=testym[cnt+maxsearch*maxsearch*0];
	    x_init[1]=testym[cnt+maxsearch*maxsearch*1];
	    x_init[2]=2.0;
	    x_init[3]=0.5;
	    x_init[4]=0.01;
	    
	    struct mass massy;
	    massy=mass_init;
	    double chi2=runchap("fitty",trial,lines,data,"Null",params,x_init,massy,0);  // skewed gaussian with client=0 seperate + all params
	    //	      if(x_init[2]>4.0)//push the chi^2 up if finding a solution with too many clients
	    //	chi2=chi2+10;
	    //if(x_init[0]<12.0)//push the chi^2 up if finding a solution with too few HSP
	    //	chi2=chi2+10;
	    if(chi2!=chi2)
	      chi2=1E6;
	    testym[cnt+maxsearch*maxsearch*2]=chi2;
	    
	    fp=fopen(labby.c_str(),"a");
	    fprintf(fp,"%e\t%e\t%e\t%e\t%e\t%e\t%e\n",testym[cnt+maxsearch*maxsearch*0],testym[cnt+maxsearch*maxsearch*1],chi2,x_init[0],x_init[1],x_init[2],x_init[3]);
	    fclose(fp);
	    cnt++;
	    
	  }
	fp=fopen(labby.c_str(),"a");
	fprintf(fp,"\n");
	fclose(fp);
      }
    
    int imin=findmin(testym,maxsearch*maxsearch,2);//find the lowest chi2 element in the test array
    
    
    //Initialise the final minimisation
    x_init[0]=testym[imin+maxsearch*maxsearch*0];   //update initialise matrix with minimsed value
    x_init[1]=testym[imin+maxsearch*maxsearch*1];   //update initialise matrix with minimised value
    x_init[2]=2.0;
    x_init[3]=0.5;
    x_init[4]=0.01;
    

    //run the final fit with these parameters
    struct mass massy;
    massy=mass_init;
    double chi2=runchap("fitty",trial,lines,data,"Null",params,x_init,massy,0);  // skewed gaussian with client=0 seperate + all params
  
  
    //update the struct with the new fitted values ready for main minimisation. Minimiser should start very close to the bottom of the well
    mass_init.MRes      =massy.MRes;
    mass_init.adduction =massy.adduction;
    mass_init.Zfudge    =massy.Zfudge;
    mass_init.ResFudge  =massy.ResFudge;
  
    if(params.chap==8)
      params.chap=0;
    if(params.chap==3)
      params.chap=2;
    */    
    return;
  }




  //Gridsearch over oligomers and zfudge
  void gridsearchSingle(int i,int j,int trial,int lines,double *data,double *x_init,struct mass& mass_init,struct control& params,string *raw,string *ident,double Max0,double Min0)
  {
  
    int maxsearch=(Max0-Min0)+1; //stepsize  for centroid
    /*
    //initiate a grid search output file and mode
    FILE *fp;
    string labby="out/chi2init.out";
    labby.append(ident[i].c_str(),4);
    
    int jj=0;
    if(j==0){//for Gaussian
      jj=0;
      char *lab="_0";labby.append(lab,2);}
    if(j==1){//for Skewed Gaussian
      jj=1;
      char *lab="_1";labby.append(lab,2);}
    fp=fopen(labby.c_str(),"w");
    fclose(fp);
    cout << "    Gridsearching... " << endl;
    //run the gridsearch to find optimum centre of substrate and client distributions
    int Zsearch=5;
    int AddSearch=2;
    double testym[Zsearch*maxsearch*AddSearch*4];
    int cnt=0;
    for (int k1=0;k1<maxsearch;k1++)
      {
	for  (int k2=0;k2<Zsearch;k2++)
	  {
	    for  (int k3=0;k3<AddSearch;k3++)
	      {
		
		testym[cnt+maxsearch*Zsearch*AddSearch*0]=Min0+(k1)/(maxsearch*1.0-1.0)*(Max0-Min0);  //grid search from 10 to 50 on 'rat'
		testym[cnt+maxsearch*Zsearch*AddSearch*1]=-2.+k2*1.;  //zfudge value
		if(k3==0)
		  testym[cnt+maxsearch*Zsearch*AddSearch*2]=1E-3;  //adduction value
		if(k3==1)
		  testym[cnt+maxsearch*Zsearch*AddSearch*2]=0.1;  //adduction value
		
		
		//	  testym[cnt+maxsearch*Zsearch*0]=24.0;  //grid search from 10 to 50 on 'rat'
		struct mass massy;
		massy=mass_init;
		x_init[0]      =testym[cnt+maxsearch*Zsearch*AddSearch*0];
		massy.Zfudge   =testym[cnt+maxsearch*Zsearch*AddSearch*1];
		massy.adduction=testym[cnt+maxsearch*Zsearch*AddSearch*2];
		
		double chi2=runchap("fitty",trial,lines,data,"Null",params,x_init,massy,0);  // skewed gaussian with client=0 seperate + all params
		if(chi2!=chi2)
		  chi2=1E6;
		testym[cnt+maxsearch*Zsearch*AddSearch*3]=chi2;
		fp=fopen(labby.c_str(),"a");
		fprintf(fp,"%e\t%e\t%e\t%e\t%e\t%e\t%e\t%e\n",testym[cnt+maxsearch*Zsearch*AddSearch*0],testym[cnt+maxsearch*Zsearch*AddSearch*1],testym[cnt+maxsearch*Zsearch*AddSearch*2],chi2,x_init[0],x_init[1],x_init[2],x_init[3]);
		fclose(fp);
		cnt++;
	      }
	  }
	fp=fopen(labby.c_str(),"a");
	fprintf(fp,"\n");
	fclose(fp);
      }
    int imin=findmin(testym,maxsearch*Zsearch*AddSearch,3);//find the lowest chi2 element in the test array
    struct mass massy;//run the final fit with these parameters
    massy=mass_init;
    x_init[0]      =testym[imin+maxsearch*Zsearch*AddSearch*0];   //update initialise matrix with minimsed value
    massy.Zfudge   =testym[imin+maxsearch*Zsearch*AddSearch*1];
    massy.adduction=testym[imin+maxsearch*Zsearch*AddSearch*2];
    
    
    cout << " Best fitting oligomer: " << x_init[0] << endl;
    cout << " Optimum Zfudge       : " << massy.Zfudge << endl;
    cout << " Optimum adduction    : " << massy.adduction << endl;
    double chi2=runchap("fitty",trial,lines,data,"Null",params,x_init,massy,0);  // skewed gaussian with client=0 seperate + all params
    //update the struct with the new fitted values ready for main minimisation. Minimiser should start very close to the bottom of the well
    mass_init.MRes      =massy.MRes;
    mass_init.adduction =massy.adduction;
    mass_init.Zfudge    =massy.Zfudge;
    mass_init.ResFudge  =massy.ResFudge;
    */
    return;
  }
  
  

vector<float> PackJiggle(mass &spec)
{
  vector<float> parsCurr;
  if(spec.fitpar.adduction_flg)
    parsCurr.push_back(spec.adduction);
  if(spec.fitpar.Zfudge_flg)
    parsCurr.push_back(spec.Zfudge);
  if(spec.fitpar.MRes_flg)
    parsCurr.push_back(spec.MRes);
  if(spec.fitpar.ResFudge_flg)
    parsCurr.push_back(spec.ResFudge);
  if(spec.fitpar.tw_flg)
    parsCurr.push_back(spec.tw);
  if(spec.fitpar.Zwidth_flg)
    parsCurr.push_back(spec.Zwidth);
  return parsCurr;
}

void UnpackJiggle(vector<float> &parsCurr,mass &spec)
{
  int i=0;
  if(spec.fitpar.adduction_flg)
    {spec.adduction=parsCurr[i];i++;}
  if(spec.fitpar.Zfudge_flg)
    {spec.Zfudge=parsCurr[i];i++;}
  if(spec.fitpar.MRes_flg)
    {spec.MRes=parsCurr[i];i++;}
  if(spec.fitpar.ResFudge_flg)
    {spec.ResFudge=parsCurr[i];i++;}
  if(spec.fitpar.tw_flg)
    {spec.tw=parsCurr[i];i++;}
  if(spec.fitpar.Zwidth_flg)
    {spec.Zwidth=parsCurr[i];i++;}

}


vector<float> AddNoise(vector<float> &parsCurr,double sigma,gsl_rng *r)
{
  vector<float> parsNew;
  for(int i=0;i<parsCurr.size();++i)
    {
      double rando=(gsl_ran_gaussian(r,sigma)+1);
      parsNew.push_back(parsCurr[i]*rando);
      cout << "   rando: " << rando << " oldpar: " << parsCurr[i] << " newpar: " << parsNew[i] << endl;
    }
  return parsNew;
}

void Jiggler(int flg,mass &spec)
{
  int jiggles=20; //max number of jiggles
  double sigma=0.1; //standard deviation for random number generator

  //initialise random number generator
  const gsl_rng_type *T;
  gsl_rng *r;
  T=gsl_rng_default;
  r=gsl_rng_alloc(T);
  
  spec.run_calc(0);
  double chi2=spec.chi2/spec.lines;
  cout << "Unleashing the jiggler!" << endl;
  cout << "Starting chi2: " << chi2 << endl;

  vector<float> parsCurr;
  parsCurr=PackJiggle(spec);

  for(int i=0;i<parsCurr.size();++i)
    {
      cout << "   ->   Startpar " << parsCurr[i] << endl;
    }

  int go=0;   //control the while loop
  int cnt=0; //control the while loop
  while(go==0)
    {

      vector<float> parsNew;
      parsNew=AddNoise(parsCurr,sigma,r);
      UnpackJiggle(parsNew,spec);
      fitty(0,spec);
      double chi2new=spec.chi2/spec.lines;
      cout << "oldchi2 "<< chi2 << " newchi2 " << chi2new << " counts " << cnt << endl;

      if(chi2new<chi2 && chi2new==chi2new)
	{
	  cnt=0;//reset counter
	  parsCurr=PackJiggle(spec);

	  //if( fabs(chi2new-chi2)>0.01)
	  
	  cout << "  yay! Have lowerered chi2 from " << chi2 << " to " << chi2new << endl;
	  chi2=chi2new;
	}

      cnt++;
      if(cnt==jiggles)
	go=1;
    }
  gsl_rng_free(r);

  UnpackJiggle(parsCurr,spec);
  spec.run_calc(1);//otherwise sim and save

}




class anal
{
 public:

  string basefile;
  vector<mass> files;

  //read in input file
  void ReadInput(string inputfile)
  {
    vector<vector<string> > infile;
    infile=MakeFileVec(inputfile.c_str());

    string tost="#";
    cout << endl << "Reading in file list from: " << inputfile << endl;
    for(int i=0;i<infile.size();++i)
      {
	//if(i!=0 && infile[i].size()>5 && infile[i][0][0]!="#")
	if(i!=0 && infile[i].size()>5 && infile[i][0].compare(tost)!=1)
	  {
	    mass spec;
	    spec.AddLine(infile[i]);
	    files.push_back(spec);
	  }
      }
    cout << endl << "Files to analyse: " << files.size() << endl;

    for (int i=0;i<files.size();i++)
      {
	int tit=0;
	cout << i+1 << " " << files[i].raw << endl;
	
	ifstream ifile(files[i].raw.c_str());
	if(ifile)
	    tit=1;
	if(tit==0)
	  {
	    cout << "Kinetic file is missing: " << files[i].raw << endl;
	    exit(100);
	  }
      }
    cout << "All input files present. No obvious errors." << endl << endl;
  }




  void runchap(string mode,int i,int verb)
  {
    //do something with outfile.
    cout << "Running mode: " << mode << endl;

    //Do this only if the outfile isn't set to 'Null'
    if(verb)
      SetTrial(i);
    files[i].mode=mode;
    
    if(mode=="fitty")
      fitty(1,files[i]);
    else if(mode=="sim")
      files[i].run_calc(1);
    else if(mode=="jiggle")
      Jiggler(1,files[i]);
    else
      {
	cout << "Mode not recognised. Aborting." << endl;
	cout  << mode << endl;
	exit(100);
      }
    
    files[i].trial++;

  }
  
  void SetTrial(int i)
  {
    string lab;
    //append tag depending on run number
    switch(files[i].trial){
    case 0:
      lab="_a";
      break;
    case 1:
      lab="_b";
      break;
    case 2:
      lab="_c";
      break;
    case 3:
      lab="_d";
      break;
    case 4:
      lab="_e";
      break;
    case 5:
      lab="_f";
      break;
    case 6:
      lab="_g";
      break;
    }
    files[i].identTag=files[i].ident+lab;
  }


};



